-- foldl и foldr
-- Решите каждую задачу с помощью одной из функций: foldl или foldr. 
-- Обычно с помощью одной из этих функций решение проще и естественней. 
-- Иногда хорошее решение можно получить обеими функциями, 
-- в этом случае попробуйте решить одну задачу двумя функциями.

-- Обратите внимание, что разные задачи имеют похожие решения с помощью 
-- функций свертки, они отличаются буквально в одной операции. 
-- Найдите такие задачи с похожими решениями.

-- Тут везде, где есть два варианта, лучше использовать тот, где :
-- ибо он меньше действий делает, достигая того же результата
-- 1 Посчитайте количество элементов в списке
fold11 :: [a] -> Int
fold11 = foldl (\x _ -> x + 1) 0

fold12 :: [a] -> Int
fold12 = foldr (\_ x -> x + 1) 0

-- 2 Переверните список
fold21 :: [a] -> [a]
fold21 = foldl (\b a -> a:b) []

fold22 :: [a] -> [a]
fold22 = foldr (\a b -> b ++ [a]) []
-- 3 Припишите один список к другому (операция ++)
fold3 :: [a] -> [a] -> [a]
-- fold3 l1 l2 = foldr (:) (foldr (:) [] l2) l1
--а ещё лучше
fold3 l1 l2 = foldr (:) l2 l1

-- 4 Реализуйте функцию filter
fold41 f = foldl (\b a -> if f a then b ++ [a] else b) []

fold42 f = foldr (\a b -> if f a then a:b else b) []
-- 5 Реализуйте функцию map
fold51 f = foldl (\b x -> b ++ [f x]) []

fold52 f = foldr (\x b -> [f x] ++ b) []
-- 6 Реализуйте функцию concatMap. 
-- Она имеет тип: (a -> [b]) -> [a] -> [b] и делает следующее: 
-- concatMap f l применяет функцию f к каждому элементу списка l и 
-- получает списки. Все полученные списки объединяются в один.
fold6 :: (a -> [b]) -> [a] -> [b]
-- fold6 f l = foldl (\b a -> b ++ [a]) [] (foldl (\b a -> b ++ (f a)) [] l)
-- там у меня на самом деле в скобочках отдельный map просто стоит
-- а ещё лучше и всё сразу
fold6 f l = foldr (\x a -> f x ++ a) [] l 

-- Это сложно и можно не делать
-- 7 Реализуйте foldl через foldr. И потом наоборот. 
-- (Подсказка: переворачивание списка мы делали через foldl, 
-- поэтому его можно использовать во втором случае)
-- fold7l f1@(k1 -> j1 -> k1) b [a] = foldr f2@(j2 -> k2 -> k2) b (rev [a]) where
--                     f2@(j2 -> k2 -> k2) = f1@(j1 -> k1 -> k1)

-- 8 Напишите функцию minmax, которая возвращает минимальный и максимальный 
-- лемент списка в виде Tuple (или списка из двух элементов, 
-- если вы еще не знаете, что такое Tuple).
fold8 :: [Int] -> (Int, Int)
fold8 (a:l) = foldl f (a, a) l where
               f (myMin, myMax) a | (a < myMin) && (a > myMax) = (a,a)
                                  | a < myMin = (a, myMax)
                                  | a > myMax = (myMin, a)
                                  | otherwise = (myMin, myMax)

-- concatMap
-- Следуюшие задачи нужно решить с помощью встроенной функции concatMap 
-- Она имеет тип: (a -> [b]) -> [a] -> [b] и делает следующее: 
-- concatMap f l применяет функцию f к каждому элементу списка l и 
-- получает списки. Все полученные списки объединяются в один.
-- 1 Дан список, повторите каждый его элемент два раза.
conM1 :: [a] -> [a]
conM1 = concatMap (\x -> [x,x])
-- 2 Опять реализуйте filter
conM2 :: (a -> Bool) -> [a] -> [a]
conM2 f = concatMap (\x -> if f x then [x] else [])
-- 3 Реализуйте map
conM3 :: (a -> b) -> [a] -> [b]
conM3 f = concatMap(\x -> [f x])